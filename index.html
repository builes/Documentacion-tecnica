<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Documentacion tecnica</title>
</head>

<body>


    <nav id="nabvar">
        <h2>POO Python</h2>
        <header>
            <ul>
                <li><a href="#classes">Classes</a></li>
            </ul>
            <ul>
                <li><a href="">Python Scopes and Namespaces</a></li>
            </ul>
            <ul>
                <li><a href="">Inheritance</a></li>
            </ul>
            <ul>
                <li><a href="">Private Variables</a></li>
            </ul>
            <ul>
                <li><a href="">A Word About Names and Objects</a></li>
            </ul>
        </header>
    </nav>


    <main id="main-doc">
        <section class="main-section" id="classes">
            <header>
                <h3>Classes</h3>
                <p>Classes provide a means of bundling data and functionality together. Creating a new class creates a
                    new type of object, allowing new instances of that type to be made. Each class instance can have
                    attributes attached to it for maintaining its state. Class instances can also have methods (defined
                    by its class) for modifying its state.</p>
                <p>Compared with other programming languages, Python’s class mechanism adds classes with a minimum of
                    new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python
                    classes provide all the standard features of Object Oriented Programming: the class inheritance
                    mechanism allows multiple base classes, a derived class can override any methods of its base class
                    or classes, and a method can call the method of a base class with the same name. Objects can contain
                    arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature
                    of Python: they are created at runtime, and can be modified further after creation.
                </p>
            </header>
        </section>

        <section class="main-section" id="scopes-and-namespaces">
            <header>
                <h3>Python Scopes and Namespaces</h3>
                <p>A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python
                    dictionaries, but that’s normally not noticeable in any way (except for performance), and it may
                    change in the future. Examples of namespaces are: the set of built-in names (containing functions
                    such as abs(), and built-in exception names); the global names in a module; and the local names in a
                    function invocation. In a sense the set of attributes of an object also form a namespace. The
                    important thing to know about namespaces is that there is absolutely no relation between names in
                    different namespaces; for instance, two different modules may both define a function
                    <code>maximize</code> without confusion — users of the modules must prefix it with the module name.
                </p>
                <p>By the way, I use the word attribute for any name following a dot — for example, in the expression
                    <code>z.real</code>, <codez>real</code> is an attribute of the object z. Strictly
                        speaking, references to
                        names in modules are attribute references: in the expression <code>modname.funcname</code>,
                        <code>modname</code> is a
                        module object and <code>funcname</code> is an attribute of it. In this case there happens to be
                        a
                        straightforward mapping between the module’s attributes and the global names defined in the
                        module: they share the same namespace!
                </p>
            </header>
        </section>
        <section class="main-section" id="inheritance">
            <header>
                <h3>Inheritance</h3>
                <p>Execution of a derived class definition proceeds the same as for a base class. When the class object
                    is constructed, the base class is remembered. This is used for resolving attribute references: if a
                    requested attribute is not found in the class, the search proceeds to look in the base class. This
                    rule is applied recursively if the base class itself is derived from some other class.</p>
                <p>There’s nothing special about instantiation of derived classes: <code>DerivedClassName()</code>
                    creates a new instance of the class. Method references are resolved as follows: the corresponding
                    class attribute is searched, descending down the chain of base classes if necessary, and the method
                    reference is valid if this yields a function object.</p>
                <p>Derived classes may override methods of their base classes. Because methods have no special
                    privileges when calling other methods of the same object, a method of a base class that calls
                    another method defined in the same base class may end up calling a method of a derived class that
                    overrides it. (For C++ programmers: all methods in Python are effectively virtual.)</p>
                <p>
                    An overriding method in a derived class may in fact want to extend rather than simply replace the
                    base class method of the same name. There is a simple way to call the base class method directly:
                    just call <code>BaseClassName.methodname(self, arguments)</code> . This is occasionally useful to
                    clients as well. (Note that this only works if the base class is accessible as BaseClassName in the
                    global scope.)
                </p>
            </header>
        </section>
        <section class="main-section" id="private-variables">
            <header>
                <h3>Private Variables</h3>
                <p>“Private” instance variables that cannot be accessed except from inside an object don’t exist in
                    Python. However, there is a convention that is followed by most Python code: a name prefixed with an
                    underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function,
                    a method or a data member). It should be considered an implementation detail and subject to change
                    without notice.</p>
                <p>Since there is a valid use-case for class-private members (namely to avoid name clashes of names with
                    names defined by subclasses), there is limited support for such a mechanism, called name mangling.
                    Any identifier of the form __spam (at least two leading underscores, at most one trailing
                    underscore) is textually replaced with <code>_classname__spam</code>, where classname is the current
                    class name with leading underscore(s) stripped. This mangling is done without regard to the
                    syntactic position of the identifier, as long as it occurs within the definition of a class.</p>

            </header>
        </section>
        <section class="main-section" id="names-and-objects">
            <header>
                <h3>A Word About Names and Objects</h3>
                <p>A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python
                    dictionaries, but that’s normally not noticeable in any way (except for performance), and it may
                    change in the future. Examples of namespaces are: the set of built-in names (containing functions
                    such as abs(), and built-in exception names); the global names in a module; and the local names in a
                    function invocation. In a sense the set of attributes of an object also form a namespace. The
                    important thing to know about namespaces is that there is absolutely no relation between names in
                    different namespaces; for instance, two different modules may both define a function
                    <code>maximize</code>
                    without confusion — users of the modules must prefix it with the module name.
                </p>
                <p>By the way, I use the word attribute for any name following a dot — for example, in the expression
                    z.real, real is an attribute of the object z. Strictly speaking, references to names in modules are
                    attribute references: in the expression <code>modname.funcname</code>, modname is a module object
                    and funcname is an attribute of it. In this case there happens to be a straightforward mapping
                    between the module’s attributes and the global names defined in the module: they share the same
                    namespace! 1</p>

            </header>
        </section>
    </main>

</body>

</html>